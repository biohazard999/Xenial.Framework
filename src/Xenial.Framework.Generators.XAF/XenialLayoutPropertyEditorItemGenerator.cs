using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

using System.Threading;

using DevExpress.ExpressApp;
using DevExpress.ExpressApp.Editors;
using DevExpress.ExpressApp.Model;
using DevExpress.ExpressApp.Model.Core;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using Xenial.Framework.Generators.Internal;
using Xenial.Framework.MsBuild;

namespace Xenial.Framework.Generators.XAF;

internal record XenialLayoutPropertyEditorItemGenerator(bool AddSources = true) : IXenialSourceGenerator
{
    public bool Accepts(TypeDeclarationSyntax typeDeclarationSyntax) => false;

    public Compilation Execute(GeneratorExecutionContext context, Compilation compilation, IList<TypeDeclarationSyntax> types, IList<string> addedSourceFiles)
    {
        (compilation, var attributeSymbol) = GenerateXenialLayoutBuilderAttribute(context, compilation, addedSourceFiles);

        foreach (var @class in types)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            var (semanticModel, @classSymbol, isAttributeDeclared) = TryGetTargetType(context, compilation, @class, attributeSymbol);
            if (!isAttributeDeclared || semanticModel is null || @classSymbol is null)
            {
                continue;
            }

            var attribute = @classSymbol.GetAttribute(attributeSymbol);

            var targetTypeString = (ITypeSymbol)attribute.ConstructorArguments[0].Value!;
            var modelTypeString = attribute.ConstructorArguments[1].Value?.ToString();

            //var targetType = Type.GetType(targetTypeString, true, false);
            var modelType = typeof(XafApplication).Assembly.GetType(modelTypeString, true, false);

            var targetTypeProperties = DistinctByName(GetPropertySymbols(classSymbol));
            var properties = GetPublicProperties(modelType);

            var builder = CurlyIndenter.Create();

            builder.WriteLine("// <auto-generated />");
            builder.WriteLine();
            builder.WriteLine("using System;");
            builder.WriteLine("using System.Runtime.CompilerServices;");
            builder.WriteLine();

            using (builder.OpenBrace($"namespace {@classSymbol.ContainingNamespace}"))
            {
                builder.WriteLine("[CompilerGenerated]");
                using (builder.OpenBrace($"partial {(@classSymbol.IsRecord ? "record" : "class")} {@classSymbol.Name}"))
                {
                    foreach (var property in properties)
                    {
                        var exists = targetTypeProperties.Any(t => t.Name == property.Name);
                        if (exists)
                        {
                            continue;
                        }

                        var shouldBeAdded = ShouldBeAdded(targetTypeString, property);

                        if (shouldBeAdded)
                        {
                            builder.WriteLine($"/// <summary>");
                            builder.WriteLine($"/// {GetDescription(property)}");
                            builder.WriteLine($"/// </summary>");
                            builder.WriteLine($"public {property.PropertyType.FullName} {property.Name} {{ get; set; }}");
                            builder.WriteLine();
                        }
                    }
                }
            }

            compilation = AddGeneratedCode(context, compilation, @class, builder, addedSourceFiles, emitFile: AddSources);
        }

        return compilation;
    }

    private static string? GetDescription(PropertyInfo propertyInfo)
    {
        var attr = propertyInfo.GetCustomAttribute<DescriptionAttribute>();
        if (attr is not null)
        {
            return attr.Description;
        }
        return null;
    }

    private static bool ShouldBeAdded(ITypeSymbol targetTypeString, PropertyInfo property)
    {
        var specialTypes = new[]
        {
            nameof(IModelPropertyEditor.ModelMember),
            nameof(IModelPropertyEditor.PropertyName),
            nameof(IModelPropertyEditor.View),
            nameof(IModelPropertyEditor.Root),
            nameof(IModelPropertyEditor.NodeCount),
            nameof(IModelPropertyEditor.Application),
            nameof(IModelPropertyEditor.PropertyEditorType),

            nameof(IModelPropertyEditor.MaxLength),

            nameof(IModelPropertyEditor.DataSourceProperty),
            nameof(IModelPropertyEditor.DataSourceCriteriaProperty),

            nameof(IModelPropertyEditor.ImageSizeMode),
            nameof(IModelPropertyEditor.ImageEditorCustomHeight),
            nameof(IModelPropertyEditor.ImageEditorMode),
            nameof(IModelPropertyEditor.ImageEditorFixedWidth),
            nameof(IModelPropertyEditor.ImageEditorFixedHeight),

            nameof(IModelPropertyEditor.LookupEditorMode),
        };

        if (specialTypes.Contains(property.Name))
        {
            return false;
        }

        foreach (var browsableAttribute in property.GetCustomAttributes<BrowsableAttribute>())
        {
            if (!browsableAttribute.Browsable)
            {
                return false;
            }
        }

        foreach (var browsableCalulatorType in property.GetCustomAttributes<ModelBrowsableAttribute>().Select(m => m.VisibilityCalculatorType))
        {
            if (browsableCalulatorType is null)
            {
                continue;
            }

            if (browsableCalulatorType == typeof(BooleanPropertyOnlyCalculator))
            {
                if (targetTypeString.SpecialType != SpecialType.System_Boolean)
                {
                    return false;
                }
            }
            if (browsableCalulatorType == typeof(StringPropertyOnlyCalculator))
            {
                if (targetTypeString.SpecialType != SpecialType.System_String)
                {
                    return false;
                }
            }

            if (browsableCalulatorType == typeof(ImagePropertyOnlyCalculator))
            {
                //TODO: byte[]
                if (targetTypeString.SpecialType != SpecialType.System_Byte)
                {
                    return false;
                }
            }

            if (browsableCalulatorType == typeof(DateTimePropertyOnlyCalculator))
            {
                if (targetTypeString.SpecialType != SpecialType.System_DateTime)
                {
                    return false;
                }
            }
        }

        return true;
    }

    private static IPropertySymbol[] DistinctByName(IPropertySymbol[] propertySymbols)
        => propertySymbols
            .GroupBy(car => car.Name)
            .Select(g => g.First())
            .ToArray();

    private static PropertyInfo[] DistinctByName(PropertyInfo[] propertySymbols)
        => propertySymbols
            .GroupBy(car => car.Name)
            .Select(g => g.First())
            .ToArray();

    private static IPropertySymbol[] GetPropertySymbols(INamedTypeSymbol @classSymbol)
    {
        var propertyInfos = new List<IPropertySymbol>();
        var considered = new List<INamedTypeSymbol>();
        var queue = new Queue<INamedTypeSymbol>();
        considered.Add(@classSymbol);
        queue.Enqueue(@classSymbol);

        var baseType = @classSymbol.BaseType;

        while (baseType is not null)
        {
            if (!considered.Contains(baseType))
            {
                considered.Add(baseType);
                queue.Enqueue(baseType);
            }
            baseType = baseType.BaseType;
        }

        while (queue.Count > 0)
        {
            var subType = queue.Dequeue();

            var typeProperties = subType.GetMembers().OfType<IPropertySymbol>();

            var newPropertyInfos = typeProperties
                .Where(x => !propertyInfos.Contains(x));

            propertyInfos.InsertRange(0, newPropertyInfos);
        }

        return propertyInfos.ToArray();
    }

    private static PropertyInfo[] GetPublicProperties(Type type)
    {
        if (type.IsInterface)
        {
            var propertyInfos = new List<PropertyInfo>();

            var considered = new List<Type>();
            var queue = new Queue<Type>();
            considered.Add(type);
            queue.Enqueue(type);
            while (queue.Count > 0)
            {
                var subType = queue.Dequeue();
                foreach (var subInterface in subType.GetInterfaces())
                {
                    if (considered.Contains(subInterface)) { continue; }

                    considered.Add(subInterface);
                    queue.Enqueue(subInterface);
                }

                var typeProperties = subType.GetProperties(
                    BindingFlags.FlattenHierarchy
                    | BindingFlags.Public
                    | BindingFlags.Instance);

                var newPropertyInfos = typeProperties
                    .Where(x => !propertyInfos.Contains(x));

                propertyInfos.InsertRange(0, newPropertyInfos);
            }

            return propertyInfos.ToArray();
        }

        return type.GetProperties(BindingFlags.FlattenHierarchy
            | BindingFlags.Public | BindingFlags.Instance);
    }

    private static (SemanticModel? semanticModel, INamedTypeSymbol? @classSymbol, bool isAttributeDeclared) TryGetTargetType(
        GeneratorExecutionContext context,
        Compilation compilation,
        TypeDeclarationSyntax @class,
        INamedTypeSymbol attribute
    )
    {
        var semanticModel = compilation.GetSemanticModel(@class.SyntaxTree);
        if (semanticModel is null)
        {
            return (semanticModel, null, false);
        }

        var symbol = semanticModel.GetDeclaredSymbol(@class, context.CancellationToken);

        if (symbol is null)
        {
            return (semanticModel, null, false);
        }

        var isAttributeDeclared = symbol.IsAttributeDeclared(attribute);

        return (semanticModel, symbol, isAttributeDeclared);
    }

    private static Compilation AddGeneratedCode(
        GeneratorExecutionContext context,
        Compilation compilation,
        TypeDeclarationSyntax @class,
        CurlyIndenter builder,
        IList<string> addedSourceFiles,
        string? hintName = null,
        bool emitFile = true
    )
    {
        var syntax = builder.ToString();
        var source = SourceText.From(syntax, Encoding.UTF8);

        var fileName = Path.GetFileNameWithoutExtension(@class.SyntaxTree.FilePath);

        if (fileName is "")
        {
            fileName = Guid.NewGuid().ToString();
        }

        hintName = string.IsNullOrEmpty(hintName) ? $"{fileName}.{@class.Identifier}.g.cs" : $"{@class.Identifier}.{hintName}.g.cs";

        if (emitFile)
        {
            if (!addedSourceFiles.Contains(hintName))
            {
                addedSourceFiles.Add(hintName);
                context.AddSource(hintName, source);
            }
        }

        var syntaxTree = CSharpSyntaxTree.ParseText(syntax, (CSharpParseOptions)context.ParseOptions, cancellationToken: context.CancellationToken);

        return compilation.AddSyntaxTrees(syntaxTree);
    }

    private (Compilation, INamedTypeSymbol) GenerateXenialLayoutBuilderAttribute(GeneratorExecutionContext context, Compilation compilation, IList<string> addedSourceFiles)
    {
        var (source, syntaxTree) = GenerateXenialLayoutBuilderAttribute(
            (CSharpParseOptions)context.ParseOptions,
            cancellationToken: context.CancellationToken
        );

        if (AddSources)
        {
            var fileName = $"XenialLayoutPropertyEditorItemAttribute.g.cs";
            addedSourceFiles.Add(fileName);
            context.AddSource(fileName, source);
        }

        compilation = compilation.AddSyntaxTrees(syntaxTree);

        var attribute = compilation.GetTypeByMetadataName("Xenial.XenialLayoutPropertyEditorItemAttribute");

        return (compilation, attribute!);
    }

    public static (SourceText source, SyntaxTree syntaxTree) GenerateXenialLayoutBuilderAttribute(
        CSharpParseOptions? parseOptions = null,
        string visibility = "internal",
        CancellationToken cancellationToken = default)
    {
        parseOptions = parseOptions ?? CSharpParseOptions.Default;

        var syntaxWriter = CurlyIndenter.Create();

        syntaxWriter.WriteLine($"using System;");
        syntaxWriter.WriteLine($"using System.ComponentModel;");
        syntaxWriter.WriteLine();

        using (syntaxWriter.OpenBrace($"namespace Xenial"))
        {
            syntaxWriter.WriteLine("[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]");

            using (syntaxWriter.OpenBrace($"{visibility} sealed class XenialLayoutPropertyEditorItemAttribute : Attribute"))
            {
                syntaxWriter.WriteLine($"public Type PropertyType {{ get; private set; }}");
                syntaxWriter.WriteLine($"public Type InterfaceType {{ get; private set; }}");
                syntaxWriter.WriteLine();
                using (syntaxWriter.OpenBrace($"{visibility} XenialLayoutPropertyEditorItemAttribute(Type propertyType, Type interfaceType)"))
                {
                    syntaxWriter.WriteLine($"this.PropertyType = propertyType;");
                    syntaxWriter.WriteLine($"this.InterfaceType = interfaceType;");
                }
            }
        }

        var syntax = syntaxWriter.ToString();
        var source = SourceText.From(syntax, Encoding.UTF8);
        var syntaxTree = CSharpSyntaxTree.ParseText(syntax, parseOptions, cancellationToken: cancellationToken);
        return (source, syntaxTree);
    }
}
