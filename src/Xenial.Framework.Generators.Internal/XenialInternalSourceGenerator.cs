using System;
using System.Globalization;
using System.Text;

using DevExpress.Persistent.Base;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

using Xenial.Framework.MsBuild;

namespace Xenial.Framework.Generators.Internal
{
    [Generator]
    public class XenialInternalSourceGenerator : ISourceGenerator
    {
        private const string xenialNamespace = "Xenial";

        public void Initialize(GeneratorInitializationContext context) { }

        public void Execute(GeneratorExecutionContext context)
        {
            var compilation = context.Compilation;

            compilation = AddTypeForwardAttribute(context, compilation);

            compilation = CopyEnumeration<PredefinedCategory>(context, compilation);
        }

        private Compilation AddTypeForwardAttribute(
            GeneratorExecutionContext context,
            Compilation compilation)
        {
            var builder = CurlyIndenter.Create();

            builder.WriteLine($"using System;");
            builder.WriteLine();

            using (builder.OpenBrace($"namespace {xenialNamespace}"))
            {
                builder.WriteLine("[AttributeUsage(AttributeTargets.All, Inherited = false)]");
                using (builder.OpenBrace($"internal sealed class XenialTypeForward : Attribute"))
                {
                    using (builder.OpenBrace($"internal XenialTypeForward(string targetType)"))
                    {
                        builder.WriteLine("this.TargetType = targetType;");
                    }

                    builder.WriteLine($"public string TargetType {{ get; set; }}");
                }
            }

            return AddSource(context, compilation, builder, "XenialTypeForward");
        }

        private Compilation CopyEnumeration<T>(
            GeneratorExecutionContext context,
            Compilation compilation,
            string prefix = "Xenial"
        )
            where T : struct, Enum
        {
            var builder = CurlyIndenter.Create();
            builder.WriteLine("// <auto-generated />");

            var @namespace = typeof(T).Namespace.Replace("DevExpress", prefix);
            var enumName = typeof(T).Name;

            builder.WriteLine("using System");
            builder.WriteLine("using System.Runtime.CompilerServices;");
            builder.WriteLine();
            builder.WriteLine("using Xenial;");
            builder.WriteLine();

            using (builder.OpenBrace($"namespace {@namespace}"))
            {
                builder.WriteLine("[CompilerGenerated]");
                builder.WriteLine($"[XenialTypeForward(\"{typeof(T).FullName}\")]");
                using (builder.OpenBrace($"public enum Xenial{enumName}"))
                {
                    foreach (T value in typeof(T).GetEnumValues())
                    {
                        var name = Enum.GetName(typeof(T), value);
                        var val = Convert.ChangeType(value, value.GetTypeCode(), CultureInfo.InvariantCulture);
                        builder.WriteLine($"{name} = {val},");
                    }
                }
            }

            return AddSource(context, compilation, builder, enumName);
        }


        private Compilation AddSource(
            GeneratorExecutionContext context,
            Compilation compilation,
            CurlyIndenter builder,
            string fileName,
            CSharpParseOptions? parseOptions = null)
        {
            parseOptions = parseOptions ?? new CSharpParseOptions(LanguageVersion.Preview);
            var syntax = builder.ToString();
            var source = SourceText.From(syntax, Encoding.UTF8);
            var syntaxTree = CSharpSyntaxTree.ParseText(syntax, parseOptions, cancellationToken: context.CancellationToken);

            context.AddSource($"{fileName}.g.cs", source);
            return compilation.AddSyntaxTrees(syntaxTree);
        }
    }
}
