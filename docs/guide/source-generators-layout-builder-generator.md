---
title: SourceGenerators - LayoutBuilderGenerator
sidebarDepth: 5
demoName: Acme.LayoutBuilderDemo
---

# LayoutBuilderGenerator - Introduction

A generator that helps you write strongly typed layouts using [DetailViewLayoutBuilders](layout-builders.md) and reduce the overhead (and syntax noise) of lambda expressions.

## Intent

When writing [DetailViewLayoutBuilders](layout-builders.md) code we write them in a strongly typed fashion. Because we know the target type upfront, we can use source generators to reduce syntax noise and help avoid mistakes that can occur when using the traditional lambda syntax. This source generator tries to minimize this weakness.

::: tip TIP
This generator also has benefits to force a cleaner structure when defining layouts, as well as helping with [Edit & Continue](https://docs.microsoft.com/visualstudio/debugger/how-to-use-edit-and-continue-csharp) and [HotReload](https://docs.microsoft.com/visualstudio/debugger/hot-reload) support.
:::

::: warning WARNING
If you are unfamiliar with [DetailViewLayoutBuilders](layout-builders.md) yet, make sure you follow the [documentation first](layout-builders.md), because this topic only focuses on the source generator details
:::

## Usage

Given you have a simple `Person/Address` class structure

<<< @../../demos/SourceGenerators/Acme.LayoutBuilderDemo/BusinessObjects/Person.cs

To use the layout source generator you need to derive from `LayoutBuilder<T>` and mark it as `partial`

```cs
using System;

using Xenial;
using Xenial.Framework.Layouts;
using Xenial.Framework.Layouts.Items.Base;

namespace Acme.Module.BusinessObjects
{
    public partial class PersonLayout : LayoutBuilder<Person>
    {
        public Layout BuildLayout() => new Layout()
        {
        }
    }
}
```

## Generated-Code

This results in generating 3 ways to access the metadata of each property from the `TargetObject`.

* `Editor.XXX` as a static and type safe factory for creating `LayoutPropertyEditorItem` items. This also supports [property trains](#property-trains).
* `Constants.XXX` as an alternative of using the rather clunky keyword `nameof(XXX)`. This also supports [property trains](#property-trains).
* `Property.XXX` (for future use)

```cs
// <auto-generated />

using System;
using System.Runtime.CompilerServices;

using Xenial.Framework.Layouts;
using Xenial.Framework.Layouts.Items;
using Xenial.Framework.Layouts.Items.Base;
using Xenial.Framework.Layouts.Items.LeafNodes;

namespace Acme.Module.BusinessObjects
{
    [CompilerGenerated]
    partial class PersonLayout
    {
        private struct PropertyIdentifier
        {
            private string propertyName;
            public string PropertyName { get { return this.propertyName; } }
            
            private PropertyIdentifier(string propertyName)
            {
                this.propertyName = propertyName;
            }
            
            public static implicit operator string(PropertyIdentifier identifier)
            {
                return identifier.PropertyName;
            }
            
            public static PropertyIdentifier Create(string propertyName)
            {
                return new PropertyIdentifier(propertyName);
            }
        }
        
        private partial struct Constants
        {
            public const string FirstName = "FirstName";
            public const string LastName = "LastName";
            public const string FullName = "FullName";
            public const string DateOfBirth = "DateOfBirth";
            public const string Address1 = "Address1";
            public const string Address2 = "Address2";
        }
        
        private partial struct Property
        {
            public static PropertyIdentifier FirstName { get { return PropertyIdentifier.Create("FirstName"); } }
            
            public static PropertyIdentifier LastName { get { return PropertyIdentifier.Create("LastName"); } }
            
            public static PropertyIdentifier FullName { get { return PropertyIdentifier.Create("FullName"); } }
            
            public static PropertyIdentifier DateOfBirth { get { return PropertyIdentifier.Create("DateOfBirth"); } }
            
            public static PropertyIdentifier Address1 { get { return PropertyIdentifier.Create("Address1"); } }
            
            public static PropertyIdentifier Address2 { get { return PropertyIdentifier.Create("Address2"); } }
            
        }
        
        private partial struct Editor
        {
            public static LayoutPropertyEditorItem FirstName { get { return LayoutPropertyEditorItem.Create("FirstName"); } }
            
            public static LayoutPropertyEditorItem LastName { get { return LayoutPropertyEditorItem.Create("LastName"); } }
            
            public static LayoutPropertyEditorItem FullName { get { return LayoutPropertyEditorItem.Create("FullName"); } }
            
            public static LayoutPropertyEditorItem DateOfBirth { get { return LayoutPropertyEditorItem.Create("DateOfBirth"); } }
            
            public static LayoutPropertyEditorItem Address1 { get { return LayoutPropertyEditorItem.Create("Address1"); } }
            
            public static LayoutPropertyEditorItem Address2 { get { return LayoutPropertyEditorItem.Create("Address2"); } }
            
        }
    }
}
```

## Advantage

* Usage of *strongly* typed property editors
* More concise layout builder code
* Better support for Edit & Continue and HotReload
* Better performance due the lack of parsing ExpressionTrees at runtime
* Supports a similar concept to [`ExpandObjectMembersAttribute`](https://docs.devexpress.com/eXpressAppFramework/DevExpress.Persistent.Base.ExpandObjectMembersAttribute) by using [`[XenialExpandMemberAttribute]`](#XenialExpandMemberAttribute)

## Drawbacks/Issues

* No target type annotation, yet
* Only works with [Inherit from `LayoutBuilder<T>` style](/guide/layout-builders-advanced-syntax.md#inherit-from-layoutbuilder-t), yet

## API-surface

A partial class inherited from `Xenial.Framework.Layouts.LayoutBuilder<T>` will follow the rules:

* It will generate metadata for all public properties of the `TTargetType`
* It will recursively generate additional metadata for nested object types when a `[Xenial.XenialExpandMember("MemberName")]` is defined with a valid [property train](#property-trains).

### Property Trains

In XAF you can define editors and criteria using the property train syntax by concatenation property names with a dot (for example `Person.Address.Country.CountryName`)
In order to access those in a type safe fashion you can use the `[Xenial.XenialExpandMember("XXX")]` which helps generating additional code that defines a boundary which properties should be generated (this would generate a lot of unused code)

```cs
[XenialExpandMember(Constants.Address1)]
[XenialExpandMember(Constants.Address2)]
[XenialExpandMember(Constants._Address1.Country)]
[XenialExpandMember(Constants._Address2.Country)]
public partial class PersonLayout : LayoutBuilder<Person> { }
```

This will generate additional nested classes that will be prefixed with the `_{PropertyName}` (due to language restrictions) and will resolved in a recursive manner.

::: tip TIP
For a detailed usage please see the [demo source](#demo-source)
:::

::: warning CAUTION
When updating from an older Xenial to a newer Xenial version, it's necessary to restart VisualStudio/VSCode after the upgrade, so Intellisense can reload the new SourceGenerator. So it may come to false positive warnings if they don't match.
:::

## Diagnostics

|ID            | Severity | Message                                                                     | Reason                                                                                 |
|:------------:|:--------:|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
|XENGEN0010    | Error    | Could not parse boolean MSBUILD variable `<GenerateXenialViewIdsAttribute>` | MsBuild variable needs to be in boolean parsable format: `true`/`false`/`True`/`False` |
|XENGEN0100    | Error    | The class using the `[XenialViewIdsAttribute]` needs to be partial          | We can not generate code for non partial classes                                       |
|XENGEN0101    | Error    | The class using the `[XenialViewIdsAttribute]` needs to be in a namespace   | We can not generate code in the global namespace                                       |

## Demo-Source

<!-- markdownlint-disable MD033 -->
You can find demo sources in the <a target="_blank" :href=" $var['gitHubUrl'] + '/tree/' + $var['gitBranch'] + '/demos/SourceGenerators/' + $frontmatter.demoName">Xenial.Framework repository</a> for in depth usage information.
<!-- markdownlint-enable MD033 -->
